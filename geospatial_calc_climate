# Auhtor: Soheil Nozari and Ryan Bailey
# Date: 12/7/2020
# Goal1: Getting projected water table changes at RF points and creating projected water table change, projected water table elevation, and projected saturated thickness rasters subsequently 
# Goal2: Using created water table elevation raster to locate water level at each borehole and calculating weighted average Sy at each borehole. Then interpolating Sy values at boreholes to create raster of Sy and getting Sy value at each RF point.
# Goal3: Using created saturated thickness raster to filter available wells; i.e. whenever aquifer saturated thickness at the place of irrigation wells drops below 9 meters or it drops below 1 meter at the place of other wells
import os
import numpy as np
import arcpy
from arcpy import env
from arcpy.sa import *
arcpy.CheckOutExtension("spatial")
arcpy.CheckOutExtension("GeoStats")
# Environmental Settings
arcpy.env.overwriteOutput = True
arcpy.env.outputCoordinateSystem = 'PROJCS["NAD_1983_UTM_Zone_14N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
folder_1 = 'F:/Finney_County/different_models_for_projection/future_projections_in_different_climate_using_RF'
# Introducing RCP and GCM
rcp_list = ['rcp45','rcp85']
gcm_list = ['bcc-csm1-1_r1i1p1','bcc-csm1-1-m_r1i1p1','BNU-ESM_r1i1p1','CanESM2_r1i1p1','CCSM4_r6i1p1','CNRM-CM5_r1i1p1','CSIRO-Mk3-6-0_r1i1p1','ENSEMBLE_MEAN',
              'GFDL-ESM2G_r1i1p1','GFDL-ESM2M_r1i1p1','HadGEM2-CC365_r1i1p1','HadGEM2-ES365_r1i1p1','inmcm4_r1i1p1','IPSL-CM5A-LR_r1i1p1','IPSL-CM5A-MR_r1i1p1',
              'IPSL-CM5B-LR_r1i1p1','MIROC5_r1i1p1','MIROC-ESM_r1i1p1','MIROC-ESM-CHEM_r1i1p1','MRI-CGCM3_r1i1p1','NorESM1-M_r1i1p1']
for rcp in rcp_list:
    for gcm in gcm_list:
        
        ######## Goal 1
        # Reading year index file
        input_file = open(os.path.join(folder_1,'year_index/'+rcp+'/'+gcm+'/year_index.txt'), 'r')
        for line in input_file:
            year = int(line[:])
        input_file.close()
        print(rcp+'_'+gcm+'_'+str(year)+'_'+'Building Water Table and Saturated Thickness Rasters')
        # Creating shapefiles of water table change at RF points in the last year
        if year == 2017:
            spatial_ref = 'GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]'
            arcpy.MakeXYEventLayer_management(os.path.join(folder_1,'initial_data/RF_points_water_table_change_in_2016/RF_Points_Wtable_Change_2016.csv'), 'LONGITUDE', 'LATITUDE', 'points_wtable_change', spatial_ref, '#')
        else:
            spatial_ref = 'GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]'
            arcpy.MakeXYEventLayer_management(os.path.join(folder_1,'projected_water_table_change_at_RF_points/'+rcp+'/'+gcm+'/RF_Points_Wtable_Change_'+str(year-1)+'.txt'), 'LONGITUDE', 'LATITUDE', 'points_wtable_change', spatial_ref, '#')            
        projected_ref = 'PROJCS["NAD_1983_UTM_Zone_14N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
        arcpy.Project_management('points_wtable_change', os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/water_table_change.shp'), projected_ref)                                
        # Interpolating last year water table changes at RF points
        arcpy.env.extent = '310000.000000 4173000.000000 396100.000000 4241000.000000'
        outkrig = Kriging(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/water_table_change.shp'),'Wtable_cha',KrigingModelOrdinary('GAUSSIAN',1000,14200,0.0743,0.0033),100,RadiusFixed(10000,11),'#')
        outkrig.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/wtable_change'))
        del(arcpy.env.extent)
        wtable_change = os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/wtable_change')
        # Importing last year water table elevation raster
        if year == 2017:
            last_year_wtable = os.path.join(folder_1,'initial_data/rasters/gwelv2016_low')
        else:
            last_year_wtable = os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year-1)+'/wtable_ele')
        # Adding last year water table change raster to last year water table elevation raster to create current year water table elevation raster
        current_year_wtable = Raster(wtable_change) + Raster(last_year_wtable)
        # Importing landsurface elevation (DEM) and bedrock elevation rasters 
        dem = os.path.join(folder_1,'initial_data/rasters/dem_rast')
        bedrock = os.path.join(folder_1,'initial_data/rasters/br_elev')
        # Filtering those regions where water table locates above land surface
        current_year_wtable_filtered_1 = Con(current_year_wtable > Raster(dem), Raster(dem), current_year_wtable)
        # Filtering those regions where water table locates below bedrock
        current_year_wtable_filtered_2 = Con(current_year_wtable_filtered_1 < Raster(bedrock), Raster(bedrock), current_year_wtable_filtered_1)
        # Clipping filtered water table elevation raster
        wtable_mask = ExtractByMask(current_year_wtable_filtered_2, os.path.join(folder_1,'initial_data/shapefiles/Cumltv_bond_prj.shp'))
        # Saving water table elevation rasters
        current_year_wtable_filtered_2.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/wtable_ele'))
        wtable_mask.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/wtablele_cl'))
        # Creating saturated thickness raster
        sthick = current_year_wtable_filtered_2 - Raster(bedrock)
        sthick_mask = ExtractByMask(sthick, os.path.join(folder_1,'initial_data/shapefiles/Cumltv_bond_prj.shp'))
        # Saving saturated thickness rasters
        sthick.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/saturated_thickness/'+rcp+'/'+gcm+'/'+str(year)+'/sthick'))
        sthick_mask.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/saturated_thickness/'+rcp+'/'+gcm+'/'+str(year)+'/sthick_cl'))
        # Removing raster and shapefiles of water table change at RF points
        arcpy.Delete_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/water_table_change.shp'))
        arcpy.Delete_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/water_table_elevation/'+rcp+'/'+gcm+'/'+str(year)+'/wtable_change'))
        
        ######## Goal 2
        print(rcp+'_'+gcm+'_'+str(year)+'_'+'Calculating Weighted Average Sy')
        # Extracting water level values at boreholes
        boreholes_points = os.path.join(folder_1,'initial_data/shapefiles/reduced_boreholes_inside_finney_and_surrounding.shp')
        boreholes_points_with_sthick = os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sthick_'+str(year)+'.shp')
        sthick_raster = os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/saturated_thickness/'+rcp+'/'+gcm+'/'+str(year)+'/sthick')
        ExtractValuesToPoints(boreholes_points, sthick_raster, boreholes_points_with_sthick, 'NONE', 'VALUE_ONLY')
        # Reading boreholes attribute table
        table_data = []
        with arcpy.da.SearchCursor(boreholes_points_with_sthick, ['Well_ID','RASTERVALU']) as cursor:
            for row in cursor:
                table_data.append(row[:])
        # Adding water table values to well logs table
        x = np.genfromtxt(os.path.join(folder_1,'initial_data/well_logs/Selected_Well_Logs_and_BR_Depth_removed_layers_below_bedrock_edit1-2.csv'), dtype = (int, float, float, float, float, float, 'U1000', 'U100', float, float, float, 'U500', float, float, float, float, float, float), delimiter = ',', skip_header = 1)
        x = [list(i) for i in x]
        x.sort(key = lambda zz: (zz[0]), reverse = False)
        w = []
        w.append(['WELL_ID', 'LONGITUDE_NAD1927', 'LATITUDE_NAD1927', 'TOP(ft)', 'BOTTOM(ft)', 'Log_Length(ft)', 'LOG', 'SOURCE', 'BR_depth_ft', 'BR_depth_m', 'BR_elev_m', 'Synonymy', 'Landsurface_elev_m', 'TOP(m)', 'BOTTOM(m)', 'Log_Length(m)','Top_elevation_m','Bottom_elevation_m','wtable_m'])
        for i in range(0,np.shape(table_data)[0]):
            first_row_index = -999
            flag = 0
            for j in range(0,np.shape(x)[0]):
                if int(table_data[i][0]) == x[j][0]:
                    w1 = []
                    w1.extend(x[j][:])
                    water_elev = x[j][10] + float(table_data[i][1])
                    w1.extend([water_elev])
                    w.append(w1[:]) 
                    first_row_index = j
                    flag = 1
                    break
            if flag == 1:
                row_index = first_row_index + 1
                while row_index < len(x) and x[row_index][0] == int(table_data[i][0]):
                    w1 = []
                    w1.extend(x[row_index][:])
                    w1.extend([water_elev])
                    w.append(w1[:])
                    row_index = row_index + 1
        f = open(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/Well_Logs_with_waterelev_'+str(year)+'.txt'),'w')
        f.write('\n'.join(','.join(map(str,i))for i in w))
        f.close()
        # Now start calculating Sy values at each borehole
        x = np.genfromtxt(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/Well_Logs_with_waterelev_'+str(year)+'.txt'), dtype = (int, float, float, float, float, float, 'U1000', 'U100', float, float, float, 'U500', float, float, float, float, float, float, float), delimiter = ',', skip_header = 1)
        x = [list(i) for i in x]
        x.sort(key = lambda zz: (zz[0]), reverse = False)
        w = []
        w.append(['WELL_ID', 'LONGITUDE_NAD1927', 'LATITUDE_NAD1927', 'Sy'])
        for i in range(0, np.shape(x)[0]):
            if x[i][0] != -999:
                # putting all well logs for the same borehole in y list
                y = []
                y.append(x[i][:])
                first_row_index = i
                row_index = first_row_index + 1
                while row_index < len(x) and x[row_index][0] == x[first_row_index][0]:
                    y.append(x[row_index][:])
                    x[row_index][0] = -999
                    row_index = row_index + 1
                # calculating Sy values
                # finding well logs located between (water table elevation + upper bound of water level changes correspondent to 95% confidenece interval) and (water table elevation + lower bound of water level changes correspondent to 95% confidenece interval) and calculate their included length in the interval; i.e. (water table + 1.08) and (water table - 2.35)
                lower_bound = y[0][18] - 2.35
                upper_bound = y[0][18] + 1.08
                layers = []
                for j in range(0, np.shape(y)[0]):
                    if y[j][16] < upper_bound and y[j][17] > lower_bound:
                        length = y[j][16] - y[j][17]
                        layers.append([y[j][11], length])
                    elif y[j][16] >= upper_bound and y[j][17] <= lower_bound:
                        length = upper_bound - lower_bound
                        layers.append([y[j][11], length])
                    elif y[j][16] > lower_bound and  y[j][16] < upper_bound and y[j][17] < lower_bound:
                        length = y[j][16] - lower_bound
                        layers.append([y[j][11], length])
                    elif y[j][16] > upper_bound and y[j][17] > lower_bound and y[j][17] < upper_bound:
                        length = upper_bound - y[j][17]
                        layers.append([y[j][11], length])
                # calculating specific yield value for each well log (interval) and put them in z list
                if len(layers) > 1:
                    z = []
                    for k in range(0,np.shape(layers)[0]):
                        lithology = layers[k][0].split('%')
                        log_sy = 0
                        for m in range(0,np.shape(lithology)[0]):
                            litho_split = lithology[m].split('_')
                            percentage = float(litho_split[0])
                            litho_type = litho_split[1]
                            # these values are acquired from the KGS manual for the southwestern KS groundwater model
                            if litho_type == 'sh' or litho_type == 'c' or litho_type == 'coal' or litho_type == 'br' or litho_type == 'rb' or litho_type == 'r' or litho_type == 'sst':
                                partial_sy = 0.03
                            elif litho_type == 'sc' or litho_type == 'ca' or litho_type == 'o' or litho_type == 'ts' or litho_type == 'fs' or litho_type == 'fsc' or litho_type == 'fmsc' or litho_type == 'm' or litho_type == 'msc' or litho_type == 's' or litho_type == 'crssc' or litho_type == 'fcrssc' or litho_type == 'mcrssc' or litho_type == 'gyp' or litho_type == 'sndr' or litho_type == 'fds' or litho_type == 'fmds' or litho_type == 'fcrsds' or litho_type == 'ds' or litho_type == 'mds' or litho_type == 'gc' or litho_type == 'mcrsds' or litho_type == 'crsds':
                                partial_sy = 0.05
                            elif litho_type == 'cesd-cg' or litho_type == 'fss' or litho_type == 'fmss' or litho_type == 'ss' or litho_type == 'mss' or litho_type == 'fcrsss' or litho_type == 'mcrsss' or litho_type == 'crsss':
                                partial_sy = 0.2
                            elif litho_type == 'fsnd' or litho_type == 'fmsnd' or litho_type == 'snd' or litho_type == 'fcrssnd' or litho_type == 'msnd' or litho_type == 'mcrssnd' or litho_type == 'cg':
                                partial_sy = 0.22
                            elif litho_type == 'crssnd' or litho_type == 'sg' or litho_type == 'fsdg' or litho_type == 'fmsdg' or litho_type == 'msdg' or litho_type == 'sdg' or litho_type == 'fcrssdg' or litho_type == 'mcrssdg' or litho_type == 'crssdg' or litho_type == 'fg' or litho_type == 'fmg' or litho_type == 'fcrsg' or litho_type == 'g' or litho_type == 'mg' or litho_type == 'mcrsg' or litho_type == 'crsg':
                                partial_sy = 0.25
                            log_sy = log_sy + (percentage/100) * partial_sy
                        z.append([log_sy,layers[k][1]])
                    # calculating the total effective length of well logs (intervals)
                    total_length = 0
                    for n in range(0,np.shape(z)[0]):
                        total_length = total_length + z[n][1]
                    # calculating Sy for each borehole
                    borehole_sy = 0
                    for p in range(0,np.shape(z)[0]):
                        borehole_sy = borehole_sy + (z[p][1]/total_length) * z[p][0]
                    sy_final = borehole_sy
                # for those boreholes that water table variations occur in one layer
                elif len(layers) == 1:
                    lithology = layers[0][0].split('%')
                    borehole_sy = 0
                    for m in range(0,np.shape(lithology)[0]):
                        litho_split = lithology[m].split('_')
                        percentage = float(litho_split[0])
                        litho_type = litho_split[1]
                        # these values are acquired from the KGS manual for the southwestern KS groundwater model
                        if litho_type == 'sh' or litho_type == 'c' or litho_type == 'coal' or litho_type == 'br' or litho_type == 'rb' or litho_type == 'r' or litho_type == 'sst':
                            partial_sy = 0.03
                        elif litho_type == 'sc' or litho_type == 'ca' or litho_type == 'o' or litho_type == 'ts' or litho_type == 'fs' or litho_type == 'fsc' or litho_type == 'fmsc' or litho_type == 'm' or litho_type == 'msc' or litho_type == 's' or litho_type == 'crssc' or litho_type == 'fcrssc' or litho_type == 'mcrssc' or litho_type == 'gyp' or litho_type == 'sndr' or litho_type == 'fds' or litho_type == 'fmds' or litho_type == 'fcrsds' or litho_type == 'ds' or litho_type == 'mds' or litho_type == 'gc' or litho_type == 'mcrsds' or litho_type == 'crsds':
                            partial_sy = 0.05
                        elif litho_type == 'cesd-cg' or litho_type == 'fss' or litho_type == 'fmss' or litho_type == 'ss' or litho_type == 'mss' or litho_type == 'fcrsss' or litho_type == 'mcrsss' or litho_type == 'crsss':
                            partial_sy = 0.2
                        elif litho_type == 'fsnd' or litho_type == 'fmsnd' or litho_type == 'snd' or litho_type == 'fcrssnd' or litho_type == 'msnd' or litho_type == 'mcrssnd' or litho_type == 'cg':
                            partial_sy = 0.22
                        elif litho_type == 'crssnd' or litho_type == 'sg' or litho_type == 'fsdg' or litho_type == 'fmsdg' or litho_type == 'msdg' or litho_type == 'sdg' or litho_type == 'fcrssdg' or litho_type == 'mcrssdg' or litho_type == 'crssdg' or litho_type == 'fg' or litho_type == 'fmg' or litho_type == 'fcrsg' or litho_type == 'g' or litho_type == 'mg' or litho_type == 'mcrsg' or litho_type == 'crsg':
                            partial_sy = 0.25
                        borehole_sy = borehole_sy + (percentage/100) * partial_sy
                    sy_final = borehole_sy
                # for those boreholes that went dried (assigning sy of the deepest layer)
                elif len(layers) == 0:
                    y.sort(key = lambda zz: (zz[17]), reverse = False)
                    lithology = y[0][11].split('%')
                    borehole_sy = 0
                    for m in range(0,np.shape(lithology)[0]):
                        litho_split = lithology[m].split('_')
                        percentage = float(litho_split[0])
                        litho_type = litho_split[1]
                    # these values are acquired from the KGS manual for the southwestern KS groundwater model
                        if litho_type == 'sh' or litho_type == 'c' or litho_type == 'coal' or litho_type == 'br' or litho_type == 'rb' or litho_type == 'r' or litho_type == 'sst':
                            partial_sy = 0.03
                        elif litho_type == 'sc' or litho_type == 'ca' or litho_type == 'o' or litho_type == 'ts' or litho_type == 'fs' or litho_type == 'fsc' or litho_type == 'fmsc' or litho_type == 'm' or litho_type == 'msc' or litho_type == 's' or litho_type == 'crssc' or litho_type == 'fcrssc' or litho_type == 'mcrssc' or litho_type == 'gyp' or litho_type == 'sndr' or litho_type == 'fds' or litho_type == 'fmds' or litho_type == 'fcrsds' or litho_type == 'ds' or litho_type == 'mds' or litho_type == 'gc' or litho_type == 'mcrsds' or litho_type == 'crsds':
                            partial_sy = 0.05
                        elif litho_type == 'cesd-cg' or litho_type == 'fss' or litho_type == 'fmss' or litho_type == 'ss' or litho_type == 'mss' or litho_type == 'fcrsss' or litho_type == 'mcrsss' or litho_type == 'crsss':
                            partial_sy = 0.2
                        elif litho_type == 'fsnd' or litho_type == 'fmsnd' or litho_type == 'snd' or litho_type == 'fcrssnd' or litho_type == 'msnd' or litho_type == 'mcrssnd' or litho_type == 'cg':
                            partial_sy = 0.22
                        elif litho_type == 'crssnd' or litho_type == 'sg' or litho_type == 'fsdg' or litho_type == 'fmsdg' or litho_type == 'msdg' or litho_type == 'sdg' or litho_type == 'fcrssdg' or litho_type == 'mcrssdg' or litho_type == 'crssdg' or litho_type == 'fg' or litho_type == 'fmg' or litho_type == 'fcrsg' or litho_type == 'g' or litho_type == 'mg' or litho_type == 'mcrsg' or litho_type == 'crsg':
                            partial_sy = 0.25
                        borehole_sy = borehole_sy + (percentage/100) * partial_sy
                    sy_final = borehole_sy
                # putting the calculated Sy value in the w list
                w.append([x[first_row_index][0], x[first_row_index][1], x[first_row_index][2], sy_final])
                x[first_row_index][0] = -999
        # writing boreholes Sy table
        f = open(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sy_'+str(year)+'.txt'),'w')
        f.write('\n'.join(','.join(map(str,i)) for i in w))
        f.close()
        # Exporting Boreholes Sy value table to shapefiles
        spatial_ref = 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433],AUTHORITY["EPSG",4267]]'
        arcpy.MakeXYEventLayer_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sy_'+str(year)+'.txt'), 'LONGITUDE_NAD1927', 'LATITUDE_NAD1927', 'boreholes_sy', spatial_ref, '#')        
        projected_ref = 'PROJCS["NAD_1983_UTM_Zone_14N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
        arcpy.Project_management('boreholes_sy', os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sy_'+str(year)+'.shp'), projected_ref)
        # Interpolating Sy
        arcpy.env.extent = '310000.000000 4173000.000000 396100.000000 4241000.000000'
        outkrig = Kriging(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sy_'+str(year)+'.shp'),'Sy',KrigingModelOrdinary('EXPONENTIAL',800,24000,0.002967,0.005545),100,RadiusFixed(3500,12),'#')
        outkrig.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/Sy_'+str(year)))
        del(arcpy.env.extent)
        outmask = ExtractByMask(outkrig, os.path.join(folder_1,'initial_data/shapefiles/Cumltv_bond_prj.shp'))
        outmask.save(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/Sy_'+str(year)+'_cl'))
        # Extracting Sy values at RF points
        rf_points = os.path.join(folder_1,'initial_data/RF_points/GIS/RF_points_for_projection.shp')
        rf_points_with_sy = os.path.join(folder_1,'Sy_RF_points/'+rcp+'/'+gcm+'/sy_rf_'+str(year)+'.shp')
        ExtractValuesToPoints(rf_points, os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/Sy_'+str(year)), rf_points_with_sy, 'NONE', 'VALUE_ONLY')
        # Exporting GIS table
        w = []
        w.append(['Point_ID','Sy'])
        with arcpy.da.SearchCursor(rf_points_with_sy, ['point_id','RASTERVALU']) as cursor:
            for row in cursor:
                w.append([int(row[0]), float(row[1])])
        # Writing RF points Sy value table
        f = open(os.path.join(folder_1,'Sy_RF_points/'+rcp+'/'+gcm+'/RF_points_sy_'+str(year)+'.txt'),'w')
        f.write('\n'.join(','.join(map(str,i)) for i in w))
        f.close()
        # Removing redundant txt files and shapefiles and rasters
        arcpy.Delete_management(os.path.join(folder_1,'Sy_RF_points/'+rcp+'/'+gcm+'/sy_rf_'+str(year)+'.shp'))
        arcpy.Delete_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sy_'+str(year)+'.shp'))
        os.remove(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sy_'+str(year)+'.txt'))
        arcpy.Delete_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/boreholes_sthick_'+str(year)+'.shp'))
        arcpy.Delete_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/Sy/'+rcp+'/'+gcm+'/'+str(year)+'/Sy_'+str(year)))
        
        ######## Goal 3
        print(rcp+'_'+gcm+'_'+str(year)+'_'+'Finding Available Wells Based on Saturated Thickness Values')
        # Creating shapefiles of available wells based on wells construction-plugging years and specified inactive years
        spatial_ref = 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433],AUTHORITY["EPSG",4267]]'
        arcpy.MakeXYEventLayer_management(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdivs_in_'+str(year)+'.txt'), 'longitude', 'latitude', 'pdivs', spatial_ref, '#')
        projected_ref = 'PROJCS["NAD_1983_UTM_Zone_14N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
        arcpy.Project_management('pdivs', os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdiv_'+str(year)+'.shp'), projected_ref)
        # Reading txt file of available wells based on wells construction-plugging years and specified inactive years
        available_wells = np.genfromtxt(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdivs_in_'+str(year)+'.txt'),dtype = (int,float,float,float,float,int,'U20'),delimiter = ',', skip_header = 1)
        available_wells = [list(i) for i in available_wells]
        # Extracting saturated thickness raster to available wells
        ExtractValuesToPoints(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdiv_'+str(year)+'.shp'), sthick_raster, os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdiv_with_sthick_'+str(year)+'.shp'), 'NONE', 'VALUE_ONLY')
        # Reading GIS table
        sthick_table = []
        with arcpy.da.SearchCursor(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdiv_with_sthick_'+str(year)+'.shp'), ['pdiv_id','RASTERVALU']) as cursor:
            for row in cursor:
                sthick_table.append(row[:])        
        # Checking saturated thickness value to determine whether a well should be active or not
        z = []
        z.append(['pdiv_id','longitude','latitude','x_coord','y_coord','well_kid','water_use','sthick_m'])
        for i in range(0, np.shape(available_wells)[0]):
            for j in range(0, np.shape(sthick_table)[0]):
                if available_wells[i][0] == int(sthick_table[j][0]):
                    sthick = float(sthick_table[j][1])
                    if available_wells[i][6] == 'IRR':
                        if sthick >= 9:
                            z1 = []
                            z1.extend(available_wells[i][:])
                            z1.extend([sthick])
                            z.append(z1[:])
                    elif available_wells[i][6] == 'IRR_IND':
                        if sthick >= 9:
                            z1 = []
                            z1.extend(available_wells[i][:])
                            z1.extend([sthick])
                            z.append(z1[:])
                        elif sthick >= 1 and sthick < 9:
                            z1 = []
                            z1.extend(available_wells[i][0:6])
                            z1.extend(['IND'])
                            z1.extend([sthick])
                            z.append(z1[:])
                    elif available_wells[i][6] == 'IRR_MUN':
                        if sthick >= 9:
                            z1 = []
                            z1.extend(available_wells[i][:])
                            z1.extend([sthick])
                            z.append(z1[:])
                        elif sthick >= 1 and sthick < 9:
                            z1 = []
                            z1.extend(available_wells[i][0:6])
                            z1.extend(['MUN'])
                            z1.extend([sthick])
                            z.append(z1[:])                
                    elif available_wells[i][6] == 'IRR_IND_MUN':
                        if sthick >= 9:
                            z1 = []
                            z1.extend(available_wells[i][:])
                            z1.extend([sthick])
                            z.append(z1[:])
                        elif sthick >= 1 and sthick < 9:
                            z1 = []
                            z1.extend(available_wells[i][0:6])
                            z1.extend(['IND_MUN'])
                            z1.extend([sthick])
                            z.append(z1[:])
                    else:
                        if sthick >= 1:
                            z1 = []
                            z1.extend(available_wells[i][:])
                            z1.extend([sthick])
                            z.append(z1[:])
                    break
        f = open(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/available_wells_with_sthick_'+str(year)+'.txt'), 'w')
        f.write('\n'.join(','.join(map(str,i)) for i in z))
        f.close()
        # Removing redundant text files, shapefiles and rasters
        arcpy.Delete_management(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdiv_'+str(year)+'.shp'))
        arcpy.Delete_management(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdiv_with_sthick_'+str(year)+'.shp'))
        arcpy.Delete_management(os.path.join(folder_1,'projected_watertable_sthick_sy_rasters/saturated_thickness/'+rcp+'/'+gcm+'/'+str(year)+'/sthick'))
        os.remove(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/pdivs_in_'+str(year)+'.txt'))
        # Creating shapefiles of available wells based on aquifer saturated thickness
        spatial_ref = 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433],AUTHORITY["EPSG",4267]]'
        arcpy.MakeXYEventLayer_management(os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/available_wells_with_sthick_'+str(year)+'.txt'), 'longitude', 'latitude', 'pdivs', spatial_ref, '#')
        projected_ref = 'PROJCS["NAD_1983_UTM_Zone_14N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
        arcpy.Project_management('pdivs', os.path.join(folder_1,'available_wells_different_years/'+rcp+'/'+gcm+'/shapefiles/available_wells_'+str(year)+'.shp'), projected_ref)        
        
